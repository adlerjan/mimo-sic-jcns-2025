# -*- coding: utf-8 -*-
#
# This script generates Figure 7: Radar range-power profile of the paper "Self-Interference Cancellation in Digital Sensing and Communication Arrays",
# to be presented at the 2025 5th IEEE International Symposium on Joint Communications & Sensing.
# It requires the results generated by the benchmark precoding script.
#
# Please refer to the README.md file for information on how to install the required dependencies.
# For additional questions, please don't hesitate to contact jan.adler@barkhauseninstitut.org .

from os import path as path

import matplotlib.pyplot as plt
import numpy as np
import scienceplots  # type: ignore
from h5py import File

from beamforming import SphericalFocus
from hermespy.hardware_loop import SelectiveLeakageCalibration, UsrpSystem

from dsp import NewJCAS
from parameters import *
from waveforms import ofdm


# Set the correct matplotlib style for IEEE papers
plt.style.use(['science', 'ieee', 'no-latex'])

scenario = UsrpSystem()
jcas_device = scenario.new_device(
    ip=BASE_STATION_IP,
    carrier_frequency=carrier_frequency,
    sampling_rate=sampling_rate,
    selected_transmit_ports=[0, 1, 2],
    selected_receive_ports=[1, 2],
    tx_gain=55.0,
    rx_gain=30.0,
    max_receive_delay=max_receive_delay,
    num_prepended_zeros=num_prepended_zeros,
    num_appended_zeros=num_appended_zeros,
    scale_transmission=False,
)

# Base station DSP chain
jcas_dsp = NewJCAS(
    max_range=3,
    waveform=ofdm,
    beam_focus=SphericalFocus(0.0, 0.0),
    normalize='amplitude',
)
jcas_device.add_dsp(jcas_dsp)

results_path = path.join(path.dirname(__file__), '..', 'results')


def estimate_mean_range_power(scenario: UsrpSystem) -> np.ndarray:
    mean_range_power = np.zeros(11, dtype=float)
    for _ in range(scenario.num_drops):
        drop = scenario.drop()
        mean_range_power += np.sum(drop.device_receptions[0].operator_receptions[0].cube.data, axis=(0, 1), keepdims=False)
    return mean_range_power / scenario.num_drops

def load_range_power_calibrated(campaign: str, selector: str):
    file = File(path.join(results_path, campaign, 'leakage_estimate.h5'), 'r')
    calibration = SelectiveLeakageCalibration.from_HDF(file['leakage_estimate'])
    file.close()
    jcas_dsp.interference_estimate = calibration.leakage_response

    # Hack: Make a single transmission to update the precoding
    jcas_dsp.transmit(jcas_device.state(), notify=False)
    scenario.replay(path.join(results_path, campaign, 'drops.h5'), campaign=selector)
    return estimate_mean_range_power(scenario)

def load_range_power_uncalibrated(selector: str):
    jcas_dsp.interference_estimate = np.zeros((jcas_device.num_digital_receive_ports, jcas_device.num_digital_transmit_ports, jcas_dsp.num_samples))

    # Hack: Make a single transmission to update the precoding
    jcas_dsp.transmit(jcas_device.state(), notify=False)

    scenario.replay(path.join(results_path, 'uncalibrated_10', 'drops.h5'), campaign=selector)
    return estimate_mean_range_power(scenario)

figure, axes = plt.subplots(squeeze=True, tight_layout=True)
range_candidates = .5 * np.arange(11) * jcas_dsp.range_resolution
axes.semilogy(range_candidates, load_range_power_uncalibrated('h0'), 'k--')
axes.semilogy(range_candidates, load_range_power_uncalibrated('h1'), 'k--', label="Uncoded")
axes.semilogy(range_candidates, load_range_power_calibrated('calibrated_10', 'h0'), 'k-')
axes.semilogy(range_candidates, load_range_power_calibrated('calibrated_10', 'h1'), 'k-', label="Precoded")
axes.vlines(1.5, 1e-6, 1e4, linestyles='dotted', label="Target Location")

axes.legend(loc='upper right', prop={'size': 6})
axes.set_xlabel('Range [m]')
axes.set_ylabel('Mean Power')
axes.set_xlim(0, 3.0)
axes.set_ylim(1e-6, 1e4)

plt.show()
