# -*- coding: utf-8 -*-
#
# This script generates Figure 4: Precoding performance of the paper "Self-Interference Cancellation in Digital Sensing and Communication Arrays",
# to be presented at the 2025 5th IEEE International Symposium on Joint Communications & Sensing.
# It requires the results generated by the benchmark precoding script.
#
# Please refer to the README.md file for information on how to install the required dependencies.
# For additional questions, please don't hesitate to contact jan.adler@barkhauseninstitut.org .

from __future__ import annotations
from os import path

import matplotlib.pyplot as plt
import numpy as np
import scienceplots  # type: ignore
from scipy.io import loadmat

# Set the correct matplotlib style for IEEE papers
plt.style.use(['science', 'ieee', 'no-latex'])

# Select the correct path
results_path = path.join(path.dirname(__file__), '..', 'results')


# Load the results from the benchmark estimation
results = np.array([0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20], dtype=float)
results_axis = 10 ** -results
analog_leakage = np.empty_like(results, dtype=float)
digital_leakage = np.empty_like(results, dtype=float)

for i, result in enumerate(results):
    result_mat = loadmat(path.join(results_path, f'calibrated_{int(result)}', 'results.mat'))
    analog_leakage[i] = result_mat['result_0'].flat[0]
    digital_leakage[i] = result_mat['result_1'].flat[0]

uncalibrated_results = loadmat(path.join(results_path, 'uncalibrated_10', 'results.mat'))
uncalibrated_analog_leakage = uncalibrated_results['result_0']
uncalibrated_digital_leakage = uncalibrated_results['result_1']

# Plot leakage
leakage_fig, leakage_axes = plt.subplots(squeeze=True, tight_layout=True)
leakage_axes.loglog(results_axis, analog_leakage, label='Precoded')
leakage_axes.hlines(uncalibrated_analog_leakage, results_axis.min(), results_axis.max(), label='Uncoded', linestyle='--')

leakage_axes.set_ylim(1e-6, 1e-1)
leakage_axes.set_xlabel(r'$\lambda$')
leakage_axes.set_ylabel('Leaking Power')
leakage_axes.legend(loc='lower left', prop={'size': 6})

# Compute the maximum leakage suppression
max_leakage_suppression = 10 * np.log10(np.max(uncalibrated_analog_leakage / analog_leakage))
print(f'Maximum leakage suppression: {max_leakage_suppression:.2E} dB')

plt.show()
